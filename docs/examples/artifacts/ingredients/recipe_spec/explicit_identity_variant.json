{
  "name": {
    "en": "Identity Variant, the Hard Way"
  },
  "description": {
    "en": "This is an identity transform in the XSLT sense, ie it gives you back what you started with, except for the license (which, in a generic solution, would be specified in the source, not here). This is the hard way to do it, which shows the framework onto which more nuanced transforms can be built."
  },
  "metadata": {
    "license": {}
  },
  "setup": [
    [
      "variable",
      "metadata",
      "json",
      ["readIngredient", ["lit", "json"], ["lit", "source"], ["lit", "metadata.json"]]
    ],
    [
      "variable",
      "ingredientsJson",
      "json",
      ["jsonSubdocument", ["getq", "metadata"], [["lit", "ingredients"]]]
    ],
    [
      "variable",
      "ingredientIds",
      ["array", "string"],
      ["keys", ["getq", "ingredientsJson"]]
    ],
    [
      "variable",
      "namesJson",
      "json",
      ["jsonSubdocument", ["getq", "metadata"], [["lit", "names"]]]
    ]
  ],
  "assembleContent": [
    [
      "message",
      ["lit", "Iterate over ingredients in source metadata, copy them, unchanged, to derived. (We could also copy to and from processing to mess with ingredients en route.) Since we have a primitive that knows about ingredients, we don't need to worry about the structure of ingredient objects."]
    ],
    [
      "forItems",
      ["string", "ingredientName"],
      ["getq", "ingredientNames"],
      [
        "copyIngredient",
        ["lit", "source"],
        ["getq", "ingredientName"],
        ["lit", "derived"],
        ["getq", "ingredientName"]
      ]
    ],
    [
      "message",
      ["lit", "Iterate over names in source, copy them, unchanged, to derived. (We can also filter the names to be copied, change individual names and create new ones.)"]
    ],
    [
      "forItems",
      ["string", "nameId"],
      ["keys", ["getq", "namesJson"]],
      [
	"copyName",
	["getq", "nameId"]
      ]
    ]
  ],
  "assembleRecipe": [
    [
      "message",
      ["lit", "I'm not sure that recipes make any sense in an identity derived variant which is basically 'here's everything in this project folder', ie we could leave this section empty, but here's how to build a recipe if wanted to. Some standard arrays and objects of, eg, book names, would help here. I've only built out the OT part of the recipe for now. We could do NT by copy and paste, or by iterating over sections, but I think we should discuss a less verbose syntax first."]
    ],
    [
      "variable",
      "otBooks",
      ["array", "string"],
      ["lit", ["GEN", "EXO", "LEV"]]
    ],
    [
      "variable",
      "ntBooks",
      ["array", "string"],
      ["lit", ["MAT", "MRK", "LUK"]]
    ],
    [
      "variable",
      "otSection",
      "string",
      ["newRecipeSection", ["lit", "/"], ["lit", "ot"]]
    ],
    [
      "variable",
      "ntSection",
      "string",
      ["newRecipeSection", ["lit", "/"], ["lit", "nt"]]
    ],
    [
      "forItems",
      ["string", "bookId"],
      ["getq", "otBooks"],
      [
        "sequence",
        [
          [
            "variable",
            "bookIngredientPath",
            "string",
            ["concat", [["lit", "book_sources/"], ["getq", "bookId"], ["lit", ".sfm"]]]
          ],
          [
            "if",
            [
              "and",
              [
                ["in", ["getq", "bookIngredientPath"], ["getq", "ingredientNames"]],
                ["in", ["getq", "bookId"], ["getq", "otBooks"]]
              ]
            ],
            [
              "sequence",
              [
                ["newRecipeElement", ["lit", "frob"], ["lit", "frob2"]],
                ["setq", "foo", ["newRecipeElement", ["lit", "frob"], ["lit", "frob2"]]]
              ]
            ]
          ]
	]
      ]
    ]
  ]
}
