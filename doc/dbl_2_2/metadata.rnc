# metadata.rnc v2.2
# Generated by mark@mark-VirtualBox using makeRNC.py
# Generated Wed Oct 24 13:03:53 2018

default namespace = ""
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

start = dblMetadataElement

# DBLMetadata

# Document types

dblMetadataElement = (translationMetadata | expressionMetadata | translationAndExpressionMetadata | paratextZipResourceMetadata)

translationMetadata = textTranslationMetadata | audioTranslationMetadata | videoTranslationMetadata

expressionMetadata = textExpressionMetadata | audioExpressionMetadata | printExpressionMetadata | videoExpressionMetadata | brailleExpressionMetadata

translationAndExpressionMetadata = textTranslationAndExpressionMetadata | audioTranslationAndExpressionMetadata | videoTranslationAndExpressionMetadata

textTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  textIdentificationElement &
  translationCommonElements &
  fullLanguageElement &
  textTranslationTypeElement &
  textFormatElement
}

audioTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  translationCommonElements &
  shortLanguageElement &
  audioTranslationTypeElement &
  audioFormatElement
}

videoTranslationMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  translationCommonElements &
  shortLanguageElement &
  videoTranslationTypeElement &
  videoFormatElement
}

textExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  textIdentificationElement &
  expressionCommonElements &
  shortLanguageElement &
  textExpressionTypeElement &
  textFormatElement
}

printExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  expressionCommonElements &
  shortLanguageElement &
  printExpressionTypeElement &
  printFormatElement
}

audioExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  expressionCommonElements &
  shortLanguageElement &
  audioExpressionTypeElement &
  audioFormatElement
}

videoExpressionMetadata = element DBLMetadata {
  identificationElement &
  dblMetadataCommonAtts &
  expressionCommonElements &
  shortLanguageElement &
  videoExpressionTypeElement &
  videoFormatElement
}

brailleExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  expressionCommonElements &
  shortLanguageElement &
  brailleExpressionTypeElement &
  brailleFormatElement
}

textTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  textIdentificationElement &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  textTranslationAndExpressionTypeElement &
  textFormatElement
}

audioTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  audioTranslationAndExpressionTypeElement &
  audioFormatElement
}

videoTranslationAndExpressionMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  identificationElement &
  translationAndExpressionCommonElements &
  fullLanguageElement &
  videoTranslationAndExpressionTypeElement &
  videoFormatElement
}

paratextZipResourceMetadata = element DBLMetadata {
  dblMetadataCommonAtts &
  paratextZipResourceIdentificationElement &
  paratextZipResourceTypeElement &
  relationshipsElement &
  paratextZipResourceAgenciesElement &
  shortLanguageElement &
  translationManifestElement &
  paratextZipResourceSourceElement &
  paratextZipResourcePublicationsElement &
  copyrightElement &
  archiveStatusElement
}

translationCommonElements = (
  commonElements &
  translationManifestElement &
  translationSourceElement
)

expressionCommonElements = (
  commonElements &
  promotionElement &
  nonTranslationManifestElement &
  publicationsElement &
  translationSourceElement?
)

translationAndExpressionCommonElements = (
  commonElements &
  promotionElement &
  translationManifestElement &
  publicationsElement &
  translationSourceElement
)

commonElements = (
  relationshipsElement &
  agenciesElement &
  countriesElement &
  namesElement &
  copyrightElement &
  progressElement? &
  archiveStatusElement
)

any_content = any_element* & text
any_element = element * { any_attribute*, any_content }
any_attribute = attribute * { text }

dblMetadataCommonAtts = (
  attribute version { "2.1" | "2.1.1" | "2.2" } &
  attribute id { bundleIdString } &
  attribute revision { revisionValue }
)

# metadata text

revisionValue = xsd:integer

bundleIdString = xsd:string { pattern = "[a-f0-9]{16}" }

# generic text

nonEmptyString = text

lenGe1String = xsd:string { minLength = "1" pattern="\S(.*\S)?" }

lenGe2String = xsd:string { minLength = "2" pattern="\S.*\S" }

lenGe2Le255String = xsd:string { minLength = "2" maxLength = "255" pattern="\S.*\S" }

lenGe1Le255String = xsd:string { minLength = "1" maxLength = "255" pattern="\S(.*\S)?" }

lenGe1Le1024String = xsd:string { minLength = "1" maxLength = "1024" pattern="\S(.*\S)?" }

lenLe255String = xsd:string { maxLength = "255" pattern="\S.*\S" }

anyURI = xsd:anyURI

# identification

identificationElement =
  element identification {
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element abbreviation { abbreviationString }? &
    element abbreviationLocal { localAbbreviationString }? &
    element description { lenGe2String } &
    element descriptionLocal { lenGe2String }? &
    element scope { scopeEnum } &
    canonSpecElement? &
    element dateCompleted { dateCompletedValue }? &
    (gbcSystemId | reapSystemId | biblicaSystemId | tmsSystemId | ptregSystemId | dbpSystemId)* &
    element bundleProducer { lenGe2String }
    }

paratextZipResourceIdentificationElement =
  element identification {
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element abbreviation { abbreviationString } &
    element abbreviationLocal { localAbbreviationString }? &
    element dateCompleted { dateCompletedValue }? &
    (ptSystemId | gbcSystemId | reapSystemId | biblicaSystemId | tmsSystemId | ptregSystemId | dbpSystemId)* &
    element bundleProducer { lenGe2String }
    }

textIdentificationElement =
  element identification {
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element abbreviation { abbreviationString } &
    element abbreviationLocal { localAbbreviationString }? &
    element description { lenGe2String } &
    element descriptionLocal { lenGe2String }? &
    element scope { scopeEnum } &
    canonSpecElement? &
    element dateCompleted { dateCompletedValue }? &
    (ptSystemId | gbcSystemId | reapSystemId | biblicaSystemId | tmsSystemId | ptregSystemId | dbpSystemId)* &
    element bundleProducer { lenGe2String }
    }

gbcSystemId =
  element systemId {
    attribute type { "gbc" },
    gbcElements
  }

gbcElements =
  element id {
    gbcId
  }

ptregSystemId =
  element systemId {
    attribute type { "ptreg" },
    ptregElements
 }

tmsSystemId =
  element systemId {
    attribute type { "tms" },
    tmsElements
  }

tmsElements =
  element id {
    tmsId
  }

ptSystemId =
  element systemId {
    attribute type { "paratext" },
    ptElements
  }

ptElements =
  element name { lenGe2String } &
  element fullName { lenGe2String } &
  element csetId { lenGe2String }? &
  element id { ptId } &
  (
    element baseId { ptId } &
    element baseName { lenGe2String }
  )?

ptregElements =
  element id { ptregId }

reapSystemId =
  element systemId {
    attribute type { "reap" },
    reapElements
  }

reapElements =
  element id { reapId }

biblicaSystemId =
  element systemId {
    attribute type { "biblica" },
    biblicaElements
  }

biblicaElements =
  element id { biblicaId }

dbpSystemId =
  element systemId {
    attribute type { "dbp" },
    dbpElements
  }

dbpElements =
  element id { dbpId }

# canon

canonSpecElement =
    element canonSpec {
        attribute type { canonTypes },
        canonComponent+
    }

canonComponent =
    element component { canonComponentEnum }

# canon text

canonTypes = "DC" | "NT" | "OT, DC, NT" | "OT, NT, DC" | "OT, NT" | "OT+, NT" | "OT" | "OT+"

canonComponentEnum =
    "armenianApostolicDC" |
    "armenianApostolicOT" |
    "armenianApostolicOT2" |
    "armenianClassicalOT" |
    "armenianNT" |
    "catholicAndAnglicanDC" |
    "catholicLxxDC" |
    "catholicLxxOT" |
    "catholicLxxSeparatedDC" |
    "catholicPlusLutheranDC" |
    "catholicVulgateDC" |
    "catholicVulgateOT" |
    "catholicVulgateSeparatedDC" |
    "czechKralickaDC" |
    "danishLutheranDC" |
    "ethiopianOrthodoxDC" |
    "ethiopianOrthodoxNT" |
    "ethiopianOrthodoxOT" |
    "ethiopianProtestantNT" |
    "ethiopianProtestantOT" |
    "georgianOrthodoxDC" |
    "georgianOrthodoxOT" |
    "georgianOrthodoxOT2" |
    "georgianSynodalDC" |
    "germanLutheranDC" |
    "greekOrthodoxDC" |
    "greekOrthodoxOT" |
    "kjvDC" |
    "kjvNonDC" |
    "lutheranNT" |
    "romanianOrthodoxDC" |
    "romanianOrthodoxOT" |
    "russianNT" |
    "russianOrthodoxDC" |
    "russianOrthodoxOT" |
    "russianProtestantOT" |
    "russianSynodalDC" |
    "syriacNT" |
    "syriacOT" |
    "tanakhOT" |
    "turkishInterconfessionalDC" |
    "vulgateCatholicBible" |
    "westernInterconfessionalDC" |
    "westernInterconfessionalDC2" |
    "westernNT" |
    "westernOT" |
    xsd:string { pattern = "X-[A-Za-z0-9][A-Za-z0-9\-]*" }

# identification text

abbreviationString = xsd:string { pattern = "[\-A-Za-z0-9]{2,12}" }

localAbbreviationString = xsd:string { minLength = "2" maxLength = "12" pattern="\S.*\S" }

biblicaId = xsd:string { pattern = "[0-9]{0,5}" }

gbcId = xsd:string { pattern = "[0-9a-f]{24}" }

tmsId = xsd:string { pattern = "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" }

ptId = xsd:string { pattern = "[0-9a-f]{40}" }

ptregId = xsd:string { pattern = "[0-9a-zA-Z]{17}" }

reapId = anyURI

dbpId = xsd:string { pattern = "[A-Z0-9]{10}" }

dateCompletedValue = xsd:date | xsd:gYear | xsd:gYearMonth | xsd:dateTime

scopeEnum = (
    "Bible" |
    "Bible with Deuterocanon" |
    "Deuterocanon" |
    "New Testament" |
    "New Testament+" |
    "Old Testament" |
    "Old Testament + Deuterocanon" |
    "Old Testament+" |
    "Portions" |
    "Selections" |
    "Shorter Bible"
)

# relationships

relationshipsElement =
  element relationships {
    (sourceRelationElement | expressionRelationElement)*
  }

sourceRelationElement =
  element relation {
    attribute relationType { "source" },
    attribute type { "text" | "audio" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer },
    attribute publicationId {publicationId}?
  }

expressionRelationElement =
  element relation {
    attribute relationType { "expression" },
    attribute type { "audio" | "print" | "video" | "braille" },
    attribute id { bundleIdString },
    attribute revision { xsd:integer },
    attribute publicationId {publicationId}?
  }

# agencies

agenciesElement =
  element agencies {
    rightsHolderElement+ &
    rightsAdminElement? &
    contributorElement+
  }

paratextZipResourceAgenciesElement =
  element agencies {
    rightsHolderElement+ &
    rightsAdminElement? &
    contributorElement?
  }

rightsHolderElement =
  element rightsHolder {
    element abbr { lenGe2String } &
    element url { anyURI }? &
    element nameLocal { lenGe2String }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

rightsAdminElement =
  element rightsAdmin {
    element url { anyURI }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
  }

contributorElement =
  element contributor {
    element content { xsd:boolean } &
    element publication { xsd:boolean }? &
    element management { xsd:boolean }? &
    element finance { xsd:boolean }? &
    element qa { xsd:boolean }? &
    element uid { agenciesUID } &
    element name { lenGe2String }
    }

# agencies text

agenciesUID = xsd:string { pattern = "[a-f0-9]{24}" }

# language

fullLanguageElement =
  element language {
    commonLanguageElements &
    element scriptCode { iso15924String } &
    element script { lenGe2String } &
    element scriptDirection { languageScriptDirectionEnum }
  }

shortLanguageElement =
  element language {
    commonLanguageElements &
    element scriptCode { iso15924String }? &
    element script { lenGe2String }? &
    element scriptDirection { languageScriptDirectionEnum }?
    }

commonLanguageElements = (
    element iso { languageIsoString } &
    element name { lenGe2String } &
    element nameLocal { lenGe2String }? &
    element ldml { ldmlString }? &
    element rod { rodString }? &
    element numerals { numeralSystemEnum }?
)

# language text

languageIsoString = xsd:string { pattern = "[a-z][a-z][a-z]" }

ldmlString = xsd:string { pattern = "[A-Za-z]{2,3}([\-_][A-Za-z0-9]+){0,4}" }

iso15924String = ( # ISO 15924
  "Adlm" |
  "Afak" |
  "Aghb" |
  "Ahom" |
  "Arab" |
  "Aran" |
  "Armi" |
  "Armn" |
  "Avst" |
  "Bali" |
  "Bamu" |
  "Bass" |
  "Batk" |
  "Beng" |
  "Blis" |
  "Bopo" |
  "Brah" |
  "Brai" |
  "Bugi" |
  "Buhd" |
  "Cakm" |
  "Cans" |
  "Cari" |
  "Cham" |
  "Cher" |
  "Cirt" |
  "Copt" |
  "Cprt" |
  "Cyrl" |
  "Cyrs" |
  "Deva" |
  "Dsrt" |
  "Dupl" |
  "Egyd" |
  "Egyh" |
  "Egyp" |
  "Elba" |
  "Ethi" |
  "Geok" |
  "Geor" |
  "Glag" |
  "Goth" |
  "Gran" |
  "Grek" |
  "Gujr" |
  "Guru" |
  "Hang" |
  "Hani" |
  "Hano" |
  "Hans" |
  "Hant" |
  "Hatr" |
  "Hebr" |
  "Hira" |
  "Hluw" |
  "Hmng" |
  "Hrkt" |
  "Hung" |
  "Inds" |
  "Ital" |
  "Java" |
  "Jpan" |
  "Jurc" |
  "Kali" |
  "Kana" |
  "Khar" |
  "Khmr" |
  "Khoj" |
  "Kitl" |
  "Kits" |
  "Knda" |
  "Kore" |
  "Kpel" |
  "Kthi" |
  "Lana" |
  "Laoo" |
  "Latn" |
  "Latf" |
  "Latg" |
  "Lepc" |
  "Limb" |
  "Lina" |
  "Linb" |
  "Lisu" |
  "Loma" |
  "Lyci" |
  "Lydi" |
  "Mahj" |
  "Mand" |
  "Mani" |
  "Marc" |
  "Maya" |
  "Mend" |
  "Merc" |
  "Mero" |
  "Mlym" |
  "Modi" |
  "Mong" |
  "Moon" |
  "Mroo" |
  "Mtei" |
  "Mult" |
  "Mymr" |
  "Narb" |
  "Nbat" |
  "Nkgb" |
  "Nkoo" |
  "Nshu" |
  "Ogam" |
  "Olck" |
  "Orkh" |
  "Orya" |
  "Osge" |
  "Osma" |
  "Palm" |
  "Pauc" |
  "Perm" |
  "Phag" |
  "Phli" |
  "Phlp" |
  "Phlv" |
  "Phnx" |
  "Plrd" |
  "Prti" |
  "Rjng" |
  "Roro" |
  "Runr" |
  "Samr" |
  "Sara" |
  "Sarb" |
  "Saur" |
  "Sgnw" |
  "Shaw" |
  "Shrd" |
  "Sidd" |
  "Sind" |
  "Sinh" |
  "Sora" |
  "Sund" |
  "Sylo" |
  "Syrc" |
  "Syre" |
  "Syrj" |
  "Syrn" |
  "Tagb" |
  "Takr" |
  "Tale" |
  "Talu" |
  "Taml" |
  "Tang" |
  "Tavt" |
  "Telu" |
  "Teng" |
  "Tfng" |
  "Tglg" |
  "Thaa" |
  "Thai" |
  "Tibt" |
  "Tirh" |
  "Ugar" |
  "Vaii" |
  "Visp" |
  "Wara" |
  "Wole" |
  "Xpeo" |
  "Xsux" |
  "Yiii" |
  "Zinh" |
  "Zmth" |
  "Zsym" |
  "Zxxx" |
  "Zyyy" |
  "Zzzz"
  )

rodString = xsd:string { pattern = "[0-9]{5}" }

languageScriptDirectionEnum = (
  "LTR" | # Left to Right
  "RTL"   # RTL (Right to Left)
)

numeralSystemEnum = (
  "Arabic" | # (a.k.a. 'Hindu') = 0123456789
  "Bengali" |
  "Burmese" |
  "Chinese" |
  "Cyrillic" |
  "Devanagari" |
  "Ethiopic" |
  "Farsi" |
  "Gujarati" |
  "Gurmukhi" |
  "Hebrew" |
  "Hindi" | # (i.e. 'Arabic' as used in Egypt)
  "Kannada" |
  "Khmer" |
  "Malayalam" |
  "Oriya" |
  "Roman" |
  "Tamil" |
  "Telugu" |
  "Thai" |
  "Tibetan"
)

# country

countriesElement = element countries { countryElement+ }

countryElement = element country {
  element iso { countryIsoString } &
  element name { lenGe2String } &
  element nameLocal { lenGe2String }?
}

# country text

countryIsoString = xsd:string { pattern = "[A-Z][A-Z]" }

# type

textTranslationTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonTextTranslationTypeElements
}

audioTranslationTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonAudioTranslationTypeElements
}

videoTranslationTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    commonVideoTranslationTypeElements
}

textExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

printExpressionTypeElement =
  element type {
    element medium { "print" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

brailleExpressionTypeElement =
  element type {
    element medium { "braille" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "true" } &
    element isConfidential { xsd:boolean }
}

textTranslationAndExpressionTypeElement =
  element type {
    element medium { "text" } &
    element hasCharacters { "true" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonTextTranslationTypeElements &
    commonTextExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

audioTranslationAndExpressionTypeElement =
  element type {
    element medium { "audio" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonAudioTranslationTypeElements &
    commonAudioExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

videoTranslationAndExpressionTypeElement =
  element type {
    element medium { "video" } &
    element hasCharacters { "false" } &
    element isTranslation { "true" } &
    element isExpression { "true" } &
    commonVideoTranslationTypeElements &
    commonVideoExpressionTypeElements &
    element isConfidential { xsd:boolean }
}

paratextZipResourceTypeElement =
  element type {
    element medium { "paratextZipResource" } &
    element hasCharacters { "true" } &
    element isTranslation { "false" } &
    element isExpression { "false" } &
    element isConfidential { xsd:boolean } &
    element projectType { paratextZipResourceProjectType }
}

commonTextTranslationTypeElements = (
  commonTranslationTypeElements &
  element projectType { textProjectType }?
)

commonAudioTranslationTypeElements = (
  commonTranslationTypeElements
)

commonVideoTranslationTypeElements = (
  commonTranslationTypeElements
)

commonTextExpressionTypeElements = (
  commonExpressionTypeElements
)

commonAudioExpressionTypeElements = (
  element dramatization { audioTypeDramatizationEnum } &
  commonExpressionTypeElements
)

commonVideoExpressionTypeElements = (
  commonExpressionTypeElements
)

commonTranslationTypeElements = (
  commonTypeElements &
  element translationType { translationTypeEnum }? &
  element audience { translationLevelEnum }?
)

commonExpressionTypeElements = (
  commonTypeElements
)

commonTypeElements = (
  empty
)

# type text

audioTypeDramatizationEnum = "Dramatized" | "Non-Dramatized" | "Single-Voice"

translationTypeEnum = (
  "First" |
  "New" |
  "Revision" |
  "Study / Help Material"
)

translationLevelEnum = (
  "Basic" |
  "Common" |
  "Common - Literary" |
  "Literary" |
  "Liturgical" |
  "Children"
)

textProjectType = (
    "Standard" |
    "Daughter" |
    "StudyBible" |
    "StudyBibleAdditions" |
    "BackTranslation" |
    "Auxiliary" |
    "TransliterationManual"|
    "TransliterationWithEncoder" |
    "Unknown"
)

paratextZipResourceProjectType = (
    textProjectType |
    "ConsultantNotes" |
    "GlobalConsultantNotes" |
    "GlobalAnthropologyNotes"
)

# format

textFormatElement =
  element format {
    element versedParagraphs { xsd:boolean }
  }

audioFormatElement = # DCMI: format
  element format { audioSubelements}

audioSubelements =
    element compression { audioCompressionEnum }? &
    element trackConfiguration { audioTrackEnum }? &
    element bitRate { xsd:integer }? &
    element bitDepth { xsd:integer }? &
    element samplingRate { xsd:integer }?

printFormatElement =
  element format {
    element pod { xsd:boolean } &
    element pageCount { xsd:positiveInteger } &
    element width { measurementString } &
    element height { measurementString } &
    element scale { percentageString } &
    element orientation { printOrientationEnum } &
    element color { printColorEnum } &
    element fonts { printFormatFontElement* } &
    element edgeSpace {
        element top { smallMeasurementString } &
        element bottom { smallMeasurementString } &
        element inside { smallMeasurementString } &
        element outside { smallMeasurementString }
        }
  }

printFormatFontElement =
  element font {
    attribute type { printFontEnum },
    text
  }

videoFormatElement =
  element format {
    element container {"MP4"} &
      videoFormatVideoStream &
      videoFormatAudioStream? &
      videoFormatSubtitleStream?
    }

videoFormatVideoStream =
  element videoStream {
      element codec { xsd:string } &
      element bitRate { xsd:positiveInteger } &
      element frameRate { xsd:decimal } &
      element screenResolution { screenResolution }
  }

videoFormatAudioStream =
  element audioStream { audioSubelements }

videoFormatSubtitleStream = element subtitleStream { empty }

brailleFormatElement =
  element format {
    element isContracted { xsd:boolean } &
    brailleLiblouisElement &
    brailleHyphenationDictionaryElement? &
    brailleNumberSignElement &
    brailleContinuousPoetryElement? &
    brailleContentElement &
    braillePageElement
  }

brailleLiblouisElement = element liblouis {
    element version { xsd:string } &
    element table {
        element source { xsd:string },
        element name { xsd:string }
    }
}

brailleHyphenationDictionaryElement = element hyphenationDictionary {
    attribute src { xsd:string },
    element name { xsd:string }
}

brailleNumberSignElement = element numberSign {
    element character { brailleString } &
    element useInMargin { xsd:boolean }
}

brailleContinuousPoetryElement = element continuousPoetry {
    element startIndicator { brailleString }? &
    element lineIndicator { brailleString }? &
    element lineIndicatorSpaced { "never" | "always" | "sometimes" } &
    element endIndicator { brailleString } ?
}

brailleContentElement = element content {
    element chapterNumberStyle {"lower" | "upper" } &
    element chapterHeadingsNumberFirst { xsd:boolean } &
    element versedParagraphs { xsd:boolean } &
    element verseSeparator { brailleString } &
    element includeIntros { xsd:boolean } &
    element footnotes {
        element callerSymbol{ brailleString }
    }? &
    element crossReferences {
        element callerSymbol{ brailleString }
    }? &
    element characterStyles {
        element emphasizedWord { brailleString }? &
        element emphasizedPassageStart { brailleString }? &
        element emphasizedPassageEnd { brailleString }?
    }?
}

braillePageElement = element page {
    element charsPerLine { xsd:positiveInteger } &
    element linesPerPage { xsd:positiveInteger } &
    element defaultMarginWidth { xsd:positiveInteger } &
    element versoLastLineBlank { xsd:boolean } &
    element carryLines { xsd:positiveInteger }
}

# format text

measurementString = xsd:string { pattern = "[1-9][0-9]{1,4}mm" }

smallMeasurementString = xsd:string { pattern = "[1-9][0-9]{0,2}mm" }

percentageString = xsd:string { pattern = "[1-9][0-9]{1,3}%" }

screenResolution = xsd:string { pattern = "[1-9][0-9]{0,3}x[1-9][0-9]{0,3}" }

audioCompressionEnum = (
  "MP3"  |
  "FLAC" |
  "WAV" |
  "AAC"
)

audioTrackEnum = (
    "1/0 (Mono)"   |
    "Dual mono"    |
    "2/0 (Stereo)" |
    "5.1 Surround"
)

printOrientationEnum = (
  "portrait" |
  "landscape"
)

printColorEnum = (
  "CMYK" |
  "RGB"
)

printFontEnum = (
  "OpenType" |
  "Other" |
  "Bitmap" |
  "TrueType" |
  "Type1"
)

brailleString = xsd:string { pattern = "([⠀-⣿])*" }

# names

namesElement =
  element names { namesName* }

namesName =
  element name {
    attribute id { nameIdString } &
    element long { lenGe1Le1024String }? &
    element short { lenGe1Le255String } &
    element abbr { lenGe1Le255String }?
  }

# name text

nameIdString = xsd:string { pattern = "[A-Za-z][\-A-Za-z0-9_]+" }

# manifest

nonTranslationManifestElement =
  element manifest { (nonTranslationManifestContainer | nonTranslationManifestResource)+ }

translationManifestElement =
  element manifest { (translationManifestContainer | translationManifestResource)+ }

nonTranslationManifestContainer =
  element container {
    attribute uri { anyURI },
    (nonTranslationManifestContainer | nonTranslationManifestResource)+
  }

translationManifestContainer =
  element container {
    attribute uri { anyURI },
    (translationManifestContainer | translationManifestResource)+
  }

# Manifest resource

translationManifestResource =
  element resource {(
    commonManifestResourceAtts &
    attribute progress { xsd:positiveInteger { maxInclusive = "999" } }?)
  }

nonTranslationManifestResource =
  element resource {
    commonManifestResourceAtts
  }

commonManifestResourceAtts = (
  attribute uri { anyURI},
  attribute size { xsd:integer },
  attribute checksum { s3Checksum }?,
  attribute mimeType { mimeTypeString }
)

# manifest text

s3Checksum = xsd:string { pattern = "[a-f0-9]{32}(\-\d+)?" }

mimeTypeString = xsd:string { pattern = "[\-a-z0-9]+/[\-a-z0-9+]+" }

# source

translationSourceElement =
  element source {
    empty |
    ( element canonicalContent { canonicalContentBook+} & element structure { (sourceStructureDivision | sourceStructureContent)+ } )
  }

paratextZipResourceSourceElement =
  element source {
    element structure { (sourceStructureDivision | sourceStructureContent)+ }
  }

sourceStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    (sourceStructureDivision | sourceStructureContent)+
  }

sourceStructureContent =
  element content {
    attribute name {nameIdString}? &
    attribute src {srcPathString} &
    attribute role {roleId}?
  }

# source text

srcPathString = xsd:string { pattern = "[A-Za-z0-9][\-A-Za-z0-9_\.]+(/[A-Za-z0-9][\-A-Za-z0-9_\.]+)*" }

srcPathPartString = xsd:string { pattern = "(((zip|xpath)://)|#).+" }

# publications

publicationsElement = # DCMI: tableOfContents
  element publications { publicationElement+ }

paratextZipResourcePublicationsElement =
  element publications { paratextZipResourcePublicationElement+ }

publicationElement =
  element publication {
  attribute id { publicationId },
  attribute default { xsd:boolean }?,
  publicationChildElements
  }

paratextZipResourcePublicationElement =
  element publication {
  attribute id { publicationId },
  attribute default { xsd:boolean }?,
  paratextZipResourcePublicationChildElements
  }

publicationChildElements = (
  element name { lenGe2String }? &
  element nameLocal { lenGe2String }? &
  element abbreviation { lenGe2String }? &
  element abbreviationLocal { lenGe2String }? &
  element description { lenGe2String }? &
  element descriptionLocal { lenGe2String }? &
  publicationCountriesElement? &
  element scope { scopeEnum }? &
  canonSpecElement? &
  element canonicalContent { canonicalContentBook+} &
  element structure { publicationDivisionsOrContent }
)
paratextZipResourcePublicationChildElements = (
  element name { lenGe2String }? &
  element nameLocal { lenGe2String }? &
  element structure { publicationDivisionsOrContent }
)

publicationCountriesElement = element countries { countryElement+ }

canonicalContentBook =
  element book {
    attribute code { canonicalBookIdEnum }
  }

# publication structure

publicationDivisionsOrContent = (publicationStructureDivision | publicationStructureContent)+

publicationStructureDivision =
  element division {
    attribute name {nameIdString},
    attribute role {roleId}?,
    publicationDivisionsOrContent
  }

publicationStructureContent =
  element content {
    attribute name {nameIdString}? &
    attribute src {srcPathString} &
    attribute role {roleId}? &
    attribute srcPart {srcPathPartString}?
  }

# publications text

roleId = ptReference | nonCanonicalBookIdEnum | knownRole | extensionRole

ptReference = xsd:string { pattern = "((GEN|EXO|LEV|NUM|DEU|JOS|JDG|RUT|1SA|2SA|1KI|2KI|1CH|2CH|EZR|NEH|EST|JOB|PSA|PRO|ECC|SNG|ISA|JER|LAM|EZK|DAN|HOS|JOL|AMO|OBA|JON|MIC|NAM|HAB|ZEP|HAG|ZEC|MAL|MAT|MRK|LUK|JHN|ACT|ROM|1CO|2CO|GAL|EPH|PHP|COL|1TH|2TH|1TI|2TI|TIT|PHM|HEB|JAS|1PE|2PE|1JN|2JN|3JN|JUD|REV|TOB|JDT|ESG|WIS|SIR|BAR|LJE|S3Y|SUS|BEL|1MA|2MA|3MA|4MA|1ES|2ES|MAN|PS2|ODA|PSS|JSA|JDB|TBS|SST|DNT|BLT|EZA|5EZ|6EZ|DAG|PS3|2BA|LBA|JUB|ENO|1MQ|2MQ|3MQ|REP|4BA|LAO)(( [1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?((,([1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?))*))|( [1-9][0-9]{0,2}:[1-9][0-9]{0,2}(-[1-9][0-9]{0,2}(:[1-9][0-9]{0,2})?)?(,(([1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?)|([1-9][0-9]{0,2}:[1-9][0-9]{0,2}(-[1-9][0-9]{0,2}(:[1-9][0-9]{0,2})?)?)))*))?)(;(((GEN|EXO|LEV|NUM|DEU|JOS|JDG|RUT|1SA|2SA|1KI|2KI|1CH|2CH|EZR|NEH|EST|JOB|PSA|PRO|ECC|SNG|ISA|JER|LAM|EZK|DAN|HOS|JOL|AMO|OBA|JON|MIC|NAM|HAB|ZEP|HAG|ZEC|MAL|MAT|MRK|LUK|JHN|ACT|ROM|1CO|2CO|GAL|EPH|PHP|COL|1TH|2TH|1TI|2TI|TIT|PHM|HEB|JAS|1PE|2PE|1JN|2JN|3JN|JUD|REV|TOB|JDT|ESG|WIS|SIR|BAR|LJE|S3Y|SUS|BEL|1MA|2MA|3MA|4MA|1ES|2ES|MAN|PS2|ODA|PSS|JSA|JDB|TBS|SST|DNT|BLT|EZA|5EZ|6EZ|DAG|PS3|2BA|LBA|JUB|ENO|1MQ|2MQ|3MQ|REP|4BA|LAO)(( [1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?((,([1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?))*))|( [1-9][0-9]{0,2}:[1-9][0-9]{0,2}(-[1-9][0-9]{0,2}(:[1-9][0-9]{0,2})?)?(,(([1-9][0-9]{0,2}(-[1-9][0-9]{0,2})?)|([1-9][0-9]{0,2}:[1-9][0-9]{0,2}(-[1-9][0-9]{0,2}(:[1-9][0-9]{0,2})?)?)))*))?)))*" }

knownRole = "sourceZip" | "sourceFile" | "lds" | "ldml" | "styles" | "vrs"

extensionRole = xsd:string { pattern = "X-[A-Za-z0-9][A-Za-z0-9\-]*" }

canonicalBookIdEnum = (OTBookIdEnum | NTBookIdEnum | DCBookIdEnum)

OTBookIdEnum = (
  "GEN" | # Genesis
  "EXO" | # Exodus
  "LEV" | # Leviticus
  "NUM" | # Numbers
  "DEU" | # Deuteronomy
  "JOS" | # Joshua
  "JDG" | # Judges
  "RUT" | # Ruth
  "1SA" | # 1 Samuel
  "2SA" | # 2 Samuel
  "1KI" | # 1 Kings
  "2KI" | # 2 Kings
  "1CH" | # 1 Chronicles
  "2CH" | # 2 Chronicles
  "EZR" | # Ezra
  "NEH" | # Nehemiah
  "EST" | # Esther (Hebrew)
  "JOB" | # Job
  "PSA" | # Psalms
  "PRO" | # Proverbs
  "ECC" | # Ecclesiastes
  "SNG" | # Song of Songs
  "ISA" | # Isaiah
  "JER" | # Jeremiah
  "LAM" | # Lamentations
  "EZK" | # Ezekiel
  "DAN" | # Daniel (Hebrew)
  "HOS" | # Hosea
  "JOL" | # Joel
  "AMO" | # Amos
  "OBA" | # Obadiah
  "JON" | # Jonah
  "MIC" | # Micah
  "NAM" | # Nahum
  "HAB" | # Habakkuk
  "ZEP" | # Zephaniah
  "HAG" | # Haggai
  "ZEC" | # Zechariah
  "MAL"   # Malachi
)

NTBookIdEnum = (
  "MAT" | # Matthew
  "MRK" | # Mark
  "LUK" | # Luke
  "JHN" | # John
  "ACT" | # Acts
  "ROM" | # Romans
  "1CO" | # 1 Corinthians
  "2CO" | # 2 Corinthians
  "GAL" | # Galatians
  "EPH" | # Ephesians
  "PHP" | # Philippians
  "COL" | # Colossians
  "1TH" | # 1 Thessalonians
  "2TH" | # 2 Thessalonians
  "1TI" | # 1 Timothy
  "2TI" | # 2 Timothy
  "TIT" | # Titus
  "PHM" | # Philemon
  "HEB" | # Hebrews
  "JAS" | # James
  "1PE" | # 1 Peter
  "2PE" | # 2 Peter
  "1JN" | # 1 John
  "2JN" | # 2 John
  "3JN" | # 3 John
  "JUD" | # Jude
  "REV"   # Revelation
)

DCBookIdEnum = (
  "TOB" | # Tobit
  "JDT" | # Judith
  "ESG" | # Esther Greek
  "WIS" | # Wisdom of Solomon
  "SIR" | # Sirach (Ecclesiasticus)
  "BAR" | # Baruch
  "LJE" | # Letter of Jeremiah
  "S3Y" | # Song of 3 Young Men
  "SUS" | # Susanna
  "BEL" | # Bel and the Dragon
  "1MA" | # 1 Maccabees
  "2MA" | # 2 Maccabees
  "3MA" | # 3 Maccabees
  "4MA" | # 4 Maccabees
  "1ES" | # 1 Esdras (Greek)
  "2ES" | # 2 Esdras (Latin)
  "MAN" | # Prayer of Manasseh
  "PS2" | # Psalm 151
  "ODA" | # Odes
  "PSS" | # Psalms of Solomon
  "JSA" | # actual variant text for JOS, now in LXA text
  "JDB" | # actual variant text for JDG, now in LXA text
  "TBS" | # actual variant text for TOB, now in LXA text
  "SST" | # actual variant text for SUS, now in LXA text
  "DNT" | # actual variant text for DAN, now in LXA text
  "BLT" | # actual variant text for BEL, now in LXA text
  "EZA" | # Apocalypse of Ezra
  "5EZ" | # 5 Ezra
  "6EZ" | # 6 Ezra
  "DAG" | # Daniel Greek
  "PS3" | # Psalms 152-155
  "2BA" | # 2 Baruch (Apocalypse)
  "LBA" | # Letter of Baruch
  "JUB" | # Jubilees
  "ENO" | # Enoch
  "1MQ" | # 1 Meqabyan
  "2MQ" | # 2 Meqabyan
  "3MQ" | # 3 Meqabyan
  "REP" | # Reproof
  "4BA" | # 4 Baruch
  "LAO"   # Laodiceans
)

nonCanonicalBookIdEnum = (
  "XXA" | # Extra A, e.g. a hymnal
  "XXB" | # Extra B
  "XXC" | # Extra C
  "XXD" | # Extra D
  "XXE" | # Extra E
  "XXF" | # Extra F
  "XXG" | # Extra G
  "FRT" | # Front Matter
  "BAK" | # Back Matter
  "OTH" | # Other Matter
  "INT" | # Introduction
  "CNC" | # Concordance
  "GLO" | # Glossary
  "TDX" | # Topical Index
  "NDX"   # Names Index
)

publicationId = xsd:string { pattern = "[A-Za-z][A-Za-z0-9_\-]{0,31}" }

# copyright

copyrightElement =
  element copyright {
    copyrightFullStatementElement? &
    copyrightShortStatementElement?
  }

copyrightFullStatementElement =
  element fullStatement { statementContent+ }

copyrightShortStatementElement =
  element shortStatement { statementContent+ }

statementContent = htmlStatementContent | plainStatementContent

htmlStatementContent =
  element statementContent {
    attribute type { "xhtml" },
    simplifiedHtml+
  }

plainStatementContent =
  element statementContent {
    attribute type { "plain" },
    text
  }

# html

simplifiedHtml = shBlockElement+

shBlockElement = (
    shP |
    shH1 |
    shH2 |
    shH3 |
    shUl |
    shOl |
    shBlockquote
)

shP = element p { mixed { shCharMarkup* } }

shH1 = element h1 { mixed { shCharMarkup* } }

shH2 = element h2 { mixed { shCharMarkup* } }

shH3 = element h3 { mixed { shCharMarkup* } }

shOl = element ol { shLi+ }

shUl = element ul { shLi+ }

shLi = element li { mixed { shCharMarkup* & shBlockElement* } }

shBlockquote = element blockquote { shBlockElement+ }

shCharMarkup = (
  shA |
  shImg |
  shBr |
  shStrong |
  shB |
  shEm |
  shI
)

shA =
  element a {
    attribute href { anyURI },
    mixed { shCharMarkup*  }
  }

shImg =
  element img {
    attribute src { anyURI },
    attribute alt { lenGe1String }
  }

shBr = element br { empty }

shStrong = element strong { mixed { shCharMarkup* } }

shB = element b { mixed { shCharMarkup* } }

shEm = element em { mixed { shCharMarkup* } }

shI = element i { mixed { shCharMarkup* } }

# promotion

promotionElement =
  element promotion {
    element promoVersionInfo {
      attribute contentType { "xhtml" },
      simplifiedHtml+
    }?
  }

# archive_status

archiveStatusElement =
  element archiveStatus {
    element bundleCreatorName {lenGe2String}? &
    element archivistName { lenGe2String } &
    element dateArchived { xsd:dateTime } &
    element dateUpdated { xsd:dateTime } &
    element comments { lenLe255String }
  }

progressElement =
  element progress {
    element book {
      attribute code {canonicalBookIdEnum},
      attribute stage {xsd:integer { minInclusive="1" maxInclusive="12" } }
    }+
  }

